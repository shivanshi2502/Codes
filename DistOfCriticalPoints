int length(ListNode* &head){
        if(head==NULL){
            return 0;
        }
        ListNode*temp=head;
        int count=0;
        while(temp!=NULL){
            temp=temp->next;
            count++;
        }
        return count;
    }
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        vector<int>ans;
        ans.push_back(-1);
        ans.push_back(-1);
        if(head==NULL||head->next==NULL){
            return ans;
        }
        int len=length(head);
        if(len<=3){
            return ans;
        }
        ListNode*prev=head;
        ListNode*curr=head->next;
        ListNode*forward=curr->next;
        int minDist=INT_MAX;
        int maxDistance=-1;
        bool firstCP=false;
        int firstCPNode=-1;
        int LastCPNode=-1;
        int count=1;
        while(forward!=NULL){
            if(forward->val < curr->val && prev->val < curr->val){
                if(!firstCP){
                    firstCP=true;
                    firstCPNode=count;
                    LastCPNode=count;
                }
                else{
                    minDist=min(minDist,count-LastCPNode);
                    LastCPNode=count;
                }
            }
            else if(forward->val > curr->val && prev->val > curr->val){
                if(!firstCP){
                    firstCP=true;
                    firstCPNode=count;
                    LastCPNode=count;
                }
                else{
                    minDist=min(minDist,count-LastCPNode);
                    LastCPNode=count;
                }
            }
            prev=curr;
            curr=forward;
            forward=forward->next;
            count++;
        }
        if(firstCPNode==-1){
            return ans;
        }
        if(LastCPNode!=firstCPNode){
            maxDistance=LastCPNode-firstCPNode;
        }
        else{
            return ans;
        }
        ans.pop_back();
        ans.pop_back();
        ans.push_back(minDist);
        ans.push_back(maxDistance);
        return ans;
    }
